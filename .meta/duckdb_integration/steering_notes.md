# Steering Notes (DuckDB Integration Project Context)

## Coding Conventions
- **Naming**: snake_case for variables/functions, PascalCase for classes
- **Imports**: Absolute imports from project root, grouped by standard library, third-party, local
- **Error Handling**: Use custom exceptions from domain layer, log errors with context
- **Documentation**: Docstrings for all public methods, comments for complex logic

## Tech Choices
- **Database**: DuckDB exclusively for all data operations (no other databases)
- **Testing**: pytest with coverage reporting, integration tests mandatory
- **Architecture**: Domain-Driven Design with clear layer separation
- **Configuration**: YAML-based configuration with environment overrides

## Do / Don't Rules
- ✅ **Do** use unified `data/financial_data.duckdb` for all database operations
- ✅ **Do** follow test-first approach (write tests before implementation)
- ✅ **Do** use dependency injection for scanner ports
- ✅ **Do** validate configuration before use
- ❌ **Don't** hardcode database paths in application code
- ❌ **Don't** use mock data in integration tests
- ❌ **Don't** skip error handling for database operations
- ❌ **Don't** create new database connections outside the unified manager

## Glossary
- **Scanner**: Trading signal detection algorithm
- **Signal**: Buy/sell trigger generated by scanner
- **Port**: Interface for external dependencies (database, APIs)
- **Adapter**: Implementation of port interface
- **Domain Entity**: Business object representing trading concepts

## Open Decisions
- [ ] Should we implement database connection retry logic?
- [ ] Should we add database health monitoring?
- [ ] Should we implement scanner result caching?