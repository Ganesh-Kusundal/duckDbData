# Steering Notes (Scanner Rule-Based Migration Project Context)

## Coding Conventions
- **Rule Naming**: Use kebab-case for rule IDs (e.g., `breakout-volume-1.5x`)
- **Schema Validation**: All rules must pass JSON Schema validation before execution
- **Error Handling**: Use custom exceptions (RuleValidationError, RuleExecutionError)
- **Logging**: Structured logging with rule_id and execution_context
- **Documentation**: All rules must have comprehensive descriptions and metadata

## Tech Choices
- **Rule Format**: JSON with JSON Schema validation
- **Database**: Unified DuckDB for both rules and market data
- **Query Builder**: Dynamic SQL generation with parameterized queries
- **Caching**: Redis for compiled queries and rule validation results
- **Testing**: pytest with hypothesis for property-based rule testing

## Do / Don't Rules
- ✅ **Do** validate all rules before execution (syntax + semantic)
- ✅ **Do** use parameterized queries to prevent SQL injection
- ✅ **Do** implement comprehensive error handling and recovery
- ✅ **Do** maintain backward compatibility during migration
- ✅ **Do** include performance metrics for all rule executions
- ❌ **Don't** allow dynamic code execution in rule definitions
- ❌ **Don't** store sensitive information in rule metadata
- ❌ **Don't** modify rules without proper validation and testing
- ❌ **Don't** execute rules without proper resource limits
- ❌ **Don't** skip performance monitoring for production rules

## Glossary
- **Rule**: JSON definition containing conditions, actions, and metadata
- **Rule Type**: Category of scanner (breakout, crp, technical, volume)
- **Condition**: Criteria that must be met for rule to trigger
- **Action**: Signal generation logic when conditions are met
- **Context**: Execution environment (date range, symbols, parameters)
- **Signal**: Trading signal generated by rule execution
- **Validation**: Process of checking rule syntax and semantic correctness

## Open Decisions
- [ ] Should we support rule inheritance/composition?
- [ ] Should we implement rule versioning with rollbacks?
- [ ] Should we add support for custom Python functions in rules?
- [ ] Should we implement rule performance-based auto-tuning?
- [ ] Should we add support for rule chains/sequences?
