"""
Trading Strategy Value Objects

This module defines value objects for trading strategies and execution parameters.
"""

from dataclasses import dataclass, field
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, Any

from domain.shared.exceptions import DomainException


class StrategyType(Enum):
    """Types of trading strategies."""
    MANUAL = "manual"
    BREAKOUT = "breakout"
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    ARBITRAGE = "arbitrage"
    SCALPING = "scalping"
    SWING = "swing"
    POSITION = "position"


class ExecutionType(Enum):
    """Types of order execution."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    TRAILING_STOP = "trailing_stop"
    ICEBERG = "iceberg"
    TWAP = "twap"
    VWAP = "vwap"


@dataclass(frozen=True)
class StrategyId:
    """Value object for Strategy ID."""
    value: str

    def __post_init__(self):
        if not self.value or not isinstance(self.value, str):
            raise DomainException("StrategyId must be a non-empty string")


@dataclass(frozen=True)
class StrategyName:
    """Value object for Strategy Name."""
    value: str

    def __post_init__(self):
        if not self.value or not isinstance(self.value, str):
            raise DomainException("StrategyName must be a non-empty string")
        if len(self.value) > 100:
            raise DomainException("StrategyName cannot exceed 100 characters")


@dataclass(frozen=True)
class RiskParameters:
    """Value object for risk management parameters."""
    max_position_size: Decimal
    max_drawdown: Decimal
    stop_loss_percentage: Decimal
    take_profit_percentage: Optional[Decimal] = None
    max_trades_per_day: Optional[int] = None

    def __post_init__(self):
        """Validate risk parameters."""
        if self.max_position_size <= 0:
            raise DomainException("Max position size must be positive")
        if not (0 < self.max_drawdown <= 1):
            raise DomainException("Max drawdown must be between 0 and 1")
        if not (0 < self.stop_loss_percentage <= 1):
            raise DomainException("Stop loss percentage must be between 0 and 1")
        if self.take_profit_percentage is not None and self.take_profit_percentage <= 0:
            raise DomainException("Take profit percentage must be positive")
        if self.max_trades_per_day is not None and self.max_trades_per_day <= 0:
            raise DomainException("Max trades per day must be positive")


@dataclass(frozen=True)
class TradingStrategy:
    """
    Trading Strategy value object.

    Defines the parameters and configuration for a trading strategy.
    """
    id: StrategyId
    name: StrategyName
    strategy_type: StrategyType
    execution_type: ExecutionType
    risk_parameters: RiskParameters
    parameters: Dict[str, Any]  # Strategy-specific parameters
    is_active: bool = True
    description: Optional[str] = None

    def __post_init__(self):
        """Validate strategy after initialization."""
        if self.description and len(self.description) > 500:
            raise DomainException("Strategy description cannot exceed 500 characters")

    def get_parameter(self, key: str, default: Any = None) -> Any:
        """Get a strategy parameter with optional default."""
        return self.parameters.get(key, default)

    def is_risk_compliant(self, position_size: Decimal, current_drawdown: Decimal) -> bool:
        """Check if a trade complies with risk parameters."""
        if position_size > self.risk_parameters.max_position_size:
            return False
        if current_drawdown > self.risk_parameters.max_drawdown:
            return False
        return True

    def calculate_stop_loss_price(self, entry_price: Decimal, is_long: bool) -> Decimal:
        """Calculate stop loss price based on strategy parameters."""
        if is_long:
            return entry_price * (1 - self.risk_parameters.stop_loss_percentage)
        else:
            return entry_price * (1 + self.risk_parameters.stop_loss_percentage)

    def calculate_take_profit_price(self, entry_price: Decimal, is_long: bool) -> Optional[Decimal]:
        """Calculate take profit price if defined."""
        if self.risk_parameters.take_profit_percentage is None:
            return None

        if is_long:
            return entry_price * (1 + self.risk_parameters.take_profit_percentage)
        else:
            return entry_price * (1 - self.risk_parameters.take_profit_percentage)


@dataclass(frozen=True)
class TradingSignal:
    """
    Trading Signal value object.

    Represents a signal generated by a trading strategy.
    """
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    confidence: Decimal
    price: Decimal
    timestamp: str
    strategy_id: StrategyId
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal after initialization."""
        if not self.symbol:
            raise DomainException("Signal must have a symbol")
        if self.signal_type not in ['BUY', 'SELL', 'HOLD']:
            raise DomainException("Signal type must be BUY, SELL, or HOLD")
        if not (0 <= self.confidence <= 1):
            raise DomainException("Confidence must be between 0 and 1")
        if self.price <= 0:
            raise DomainException("Price must be positive")

    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type == 'BUY'

    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type == 'SELL'

    def is_strong_signal(self, threshold: Decimal = Decimal('0.7')) -> bool:
        """Check if signal confidence is above threshold."""
        return self.confidence >= threshold
