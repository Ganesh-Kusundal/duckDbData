"""
Scanning Scan Entity

This module defines the Scan entity and related value objects for the Scanning domain.
Scans represent market scanning operations that generate trading signals.
"""

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import List, Optional, Dict, Any
from uuid import uuid4

from domain.shared.exceptions import DomainException


class ScanType(Enum):
    """Types of market scans."""
    BREAKOUT = "breakout"
    CONSOLIDATION = "consolidation"
    TREND = "trend"
    VOLUME = "volume"
    MOMENTUM = "momentum"
    REVERSAL = "reversal"
    GAP = "gap"
    VOLATILITY = "volatility"


class ScanStatus(Enum):
    """Scan execution status."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class SignalStrength(Enum):
    """Signal strength levels."""
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"


@dataclass(frozen=True)
class ScanId:
    """Value object for Scan ID."""
    value: str

    def __post_init__(self):
        if not self.value or not isinstance(self.value, str):
            raise DomainException("ScanId must be a non-empty string")

    @classmethod
    def generate(cls) -> 'ScanId':
        """Generate a new unique ScanId."""
        return cls(str(uuid4()))


@dataclass(frozen=True)
class ScanName:
    """Value object for Scan Name."""
    value: str

    def __post_init__(self):
        if not self.value or not isinstance(self.value, str):
            raise DomainException("ScanName must be a non-empty string")
        if len(self.value) > 100:
            raise DomainException("ScanName cannot exceed 100 characters")


@dataclass(frozen=True)
class ScanCriteria:
    """Value object for scan criteria and parameters."""
    scan_type: ScanType
    parameters: Dict[str, Any]
    filters: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate scan criteria."""
        if not self.parameters:
            raise DomainException("Scan parameters are required")

        # Validate scan type specific parameters
        self._validate_scan_parameters()

    def _validate_scan_parameters(self):
        """Validate parameters based on scan type."""
        if self.scan_type == ScanType.BREAKOUT:
            required_params = ['timeframe', 'min_volume', 'min_price_change']
            for param in required_params:
                if param not in self.parameters:
                    raise DomainException(f"Breakout scan requires {param} parameter")

        elif self.scan_type == ScanType.CONSOLIDATION:
            if 'consolidation_period' not in self.parameters:
                raise DomainException("Consolidation scan requires consolidation_period parameter")

        elif self.scan_type == ScanType.VOLUME:
            if 'volume_multiplier' not in self.parameters:
                raise DomainException("Volume scan requires volume_multiplier parameter")

    def get_parameter(self, key: str, default: Any = None) -> Any:
        """Get a scan parameter with optional default."""
        return self.parameters.get(key, default)

    def get_filter(self, key: str, default: Any = None) -> Any:
        """Get a scan filter with optional default."""
        return self.filters.get(key, default)


@dataclass(frozen=True)
class Signal:
    """
    Signal value object representing a trading signal.

    Signals are immutable representations of trading opportunities
    generated by scanning operations.
    """
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: SignalStrength
    confidence: Decimal
    price: Decimal
    volume: Optional[int] = None
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal after initialization."""
        if not self.symbol:
            raise DomainException("Signal must have a symbol")
        if self.signal_type not in ['BUY', 'SELL', 'HOLD']:
            raise DomainException("Signal type must be BUY, SELL, or HOLD")
        if not (0 <= self.confidence <= 1):
            raise DomainException("Confidence must be between 0 and 1")
        if self.price <= 0:
            raise DomainException("Price must be positive")

    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type == 'BUY'

    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type == 'SELL'

    def is_strong_signal(self) -> bool:
        """Check if signal strength is strong or very strong."""
        return self.strength in [SignalStrength.STRONG, SignalStrength.VERY_STRONG]

    def get_signal_score(self) -> Decimal:
        """Calculate overall signal score (confidence * strength multiplier)."""
        strength_multiplier = {
            SignalStrength.WEAK: Decimal('0.5'),
            SignalStrength.MODERATE: Decimal('0.75'),
            SignalStrength.STRONG: Decimal('1.0'),
            SignalStrength.VERY_STRONG: Decimal('1.25')
        }
        return self.confidence * strength_multiplier[self.strength]


@dataclass
class Scan:
    """
    Scan aggregate root.

    Represents a market scanning operation with its lifecycle,
    criteria, and generated signals.
    """
    id: ScanId
    name: ScanName
    criteria: ScanCriteria
    status: ScanStatus = ScanStatus.PENDING
    signals: List[Signal] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.utcnow)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
    execution_time_seconds: Optional[float] = None

    def __post_init__(self):
        """Validate scan after initialization."""
        self._validate_scan()

    def _validate_scan(self):
        """Validate scan parameters."""
        # Additional business rules can be added here
        pass

    def start_execution(self) -> None:
        """Mark scan as started."""
        if self.status != ScanStatus.PENDING:
            raise DomainException(f"Cannot start scan with status: {self.status.value}")

        self.status = ScanStatus.RUNNING
        self.started_at = datetime.utcnow()

    def complete_execution(self, signals: List[Signal]) -> None:
        """Mark scan as completed with results."""
        if self.status != ScanStatus.RUNNING:
            raise DomainException(f"Cannot complete scan with status: {self.status.value}")

        self.status = ScanStatus.COMPLETED
        self.signals = signals
        self.completed_at = datetime.utcnow()

        if self.started_at:
            self.execution_time_seconds = (self.completed_at - self.started_at).total_seconds()

    def fail_execution(self, error_message: str) -> None:
        """Mark scan as failed."""
        if self.status not in [ScanStatus.PENDING, ScanStatus.RUNNING]:
            raise DomainException(f"Cannot fail scan with status: {self.status.value}")

        self.status = ScanStatus.FAILED
        self.error_message = error_message
        self.completed_at = datetime.utcnow()

        if self.started_at and self.completed_at:
            self.execution_time_seconds = (self.completed_at - self.started_at).total_seconds()

    def cancel_execution(self) -> None:
        """Cancel scan execution."""
        if self.status not in [ScanStatus.PENDING, ScanStatus.RUNNING]:
            raise DomainException(f"Cannot cancel scan with status: {self.status.value}")

        self.status = ScanStatus.CANCELLED
        self.completed_at = datetime.utcnow()

        if self.started_at and self.completed_at:
            self.execution_time_seconds = (self.completed_at - self.started_at).total_seconds()

    def is_completed(self) -> bool:
        """Check if scan is completed."""
        return self.status == ScanStatus.COMPLETED

    def is_failed(self) -> bool:
        """Check if scan failed."""
        return self.status == ScanStatus.FAILED

    def is_running(self) -> bool:
        """Check if scan is currently running."""
        return self.status == ScanStatus.RUNNING

    def get_signal_count(self) -> int:
        """Get the number of signals generated."""
        return len(self.signals)

    def get_buy_signals(self) -> List[Signal]:
        """Get all buy signals."""
        return [signal for signal in self.signals if signal.is_buy_signal()]

    def get_sell_signals(self) -> List[Signal]:
        """Get all sell signals."""
        return [signal for signal in self.signals if signal.is_sell_signal()]

    def get_strong_signals(self) -> List[Signal]:
        """Get all strong signals."""
        return [signal for signal in self.signals if signal.is_strong_signal()]

    def get_top_signals(self, limit: int = 10) -> List[Signal]:
        """Get top signals by score."""
        sorted_signals = sorted(
            self.signals,
            key=lambda s: s.get_signal_score(),
            reverse=True
        )
        return sorted_signals[:limit]

    def get_signal_summary(self) -> Dict[str, Any]:
        """Get summary statistics of signals."""
        if not self.signals:
            return {
                'total_signals': 0,
                'buy_signals': 0,
                'sell_signals': 0,
                'strong_signals': 0,
                'avg_confidence': 0,
                'avg_signal_score': 0
            }

        buy_signals = len(self.get_buy_signals())
        sell_signals = len(self.get_sell_signals())
        strong_signals = len(self.get_strong_signals())

        avg_confidence = sum(s.confidence for s in self.signals) / len(self.signals)
        avg_signal_score = sum(s.get_signal_score() for s in self.signals) / len(self.signals)

        return {
            'total_signals': len(self.signals),
            'buy_signals': buy_signals,
            'sell_signals': sell_signals,
            'strong_signals': strong_signals,
            'avg_confidence': avg_confidence,
            'avg_signal_score': avg_signal_score
        }
