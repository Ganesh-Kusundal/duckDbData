"""
Signal Generator

This module generates trading signals from rule execution results including:
- Signal creation with confidence scoring
- Risk management calculations
- Signal validation and filtering
- Performance tracking
"""

from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, field
from datetime import datetime, date, time
from decimal import Decimal
import logging

from ..schema.rule_types import SignalType

logger = logging.getLogger(__name__)


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a rule."""
    symbol: str
    rule_id: str
    signal_type: SignalType
    confidence: float
    timestamp: datetime = field(default_factory=datetime.now)
    price: Optional[float] = None
    volume: Optional[int] = None
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size_pct: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    risk_metrics: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal after creation."""
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")

        if self.signal_type not in [SignalType.BUY, SignalType.SELL, SignalType.HOLD, SignalType.ALERT]:
            raise ValueError(f"Invalid signal type: {self.signal_type}")

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for serialization."""
        return {
            'symbol': self.symbol,
            'rule_id': self.rule_id,
            'signal_type': self.signal_type.value,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'volume': self.volume,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'position_size_pct': self.position_size_pct,
            'metadata': self.metadata,
            'risk_metrics': self.risk_metrics
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradingSignal':
        """Create signal from dictionary."""
        return cls(
            symbol=data['symbol'],
            rule_id=data['rule_id'],
            signal_type=SignalType(data['signal_type']),
            confidence=data['confidence'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            price=data.get('price'),
            volume=data.get('volume'),
            entry_price=data.get('entry_price'),
            stop_loss=data.get('stop_loss'),
            take_profit=data.get('take_profit'),
            position_size_pct=data.get('position_size_pct'),
            metadata=data.get('metadata', {}),
            risk_metrics=data.get('risk_metrics', {})
        )

    def calculate_risk_reward_ratio(self) -> Optional[float]:
        """Calculate risk-reward ratio."""
        if not all([self.entry_price, self.stop_loss, self.take_profit]):
            return None

        if self.signal_type == SignalType.BUY:
            risk = self.entry_price - self.stop_loss
            reward = self.take_profit - self.entry_price
        elif self.signal_type == SignalType.SELL:
            risk = self.stop_loss - self.entry_price
            reward = self.entry_price - self.take_profit
        else:
            return None

        return reward / risk if risk > 0 else None

    def validate_signal(self) -> List[str]:
        """Validate signal for consistency and safety."""
        errors = []

        # Basic validations
        if self.confidence < 0 or self.confidence > 1:
            errors.append(f"Invalid confidence: {self.confidence}")

        # Price validations
        if self.price and self.price <= 0:
            errors.append(f"Invalid price: {self.price}")

        if self.entry_price and self.entry_price <= 0:
            errors.append(f"Invalid entry price: {self.entry_price}")

        # Risk management validations
        if self.stop_loss and self.entry_price:
            if self.signal_type == SignalType.BUY and self.stop_loss >= self.entry_price:
                errors.append("Stop loss should be below entry price for BUY signals")
            elif self.signal_type == SignalType.SELL and self.stop_loss <= self.entry_price:
                errors.append("Stop loss should be above entry price for SELL signals")

        if self.take_profit and self.entry_price:
            if self.signal_type == SignalType.BUY and self.take_profit <= self.entry_price:
                errors.append("Take profit should be above entry price for BUY signals")
            elif self.signal_type == SignalType.SELL and self.take_profit >= self.entry_price:
                errors.append("Take profit should be below entry price for SELL signals")

        # Position size validation
        if self.position_size_pct and (self.position_size_pct <= 0 or self.position_size_pct > 100):
            errors.append(f"Invalid position size percentage: {self.position_size_pct}")

        return errors


@dataclass
class SignalBatch:
    """Represents a batch of trading signals."""
    signals: List[TradingSignal] = field(default_factory=list)
    batch_id: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Initialize batch."""
        if not self.batch_id:
            self.batch_id = f"batch_{int(datetime.now().timestamp())}_{id(self)}"

    def add_signal(self, signal: TradingSignal):
        """Add a signal to the batch."""
        self.signals.append(signal)

    def get_signals_by_type(self, signal_type: SignalType) -> List[TradingSignal]:
        """Get signals of a specific type."""
        return [s for s in self.signals if s.signal_type == signal_type]

    def get_signals_by_symbol(self, symbol: str) -> List[TradingSignal]:
        """Get signals for a specific symbol."""
        return [s for s in self.signals if s.symbol == symbol]

    def get_high_confidence_signals(self, threshold: float = 0.8) -> List[TradingSignal]:
        """Get high confidence signals."""
        return [s for s in self.signals if s.confidence >= threshold]

    def calculate_batch_metrics(self) -> Dict[str, Any]:
        """Calculate batch-level metrics."""
        if not self.signals:
            return {}

        confidences = [s.confidence for s in self.signals]
        symbols = set(s.symbol for s in self.signals)
        signal_types = [s.signal_type for s in self.signals]

        return {
            'total_signals': len(self.signals),
            'unique_symbols': len(symbols),
            'avg_confidence': sum(confidences) / len(confidences),
            'max_confidence': max(confidences),
            'min_confidence': min(confidences),
            'signal_type_distribution': {
                'BUY': signal_types.count(SignalType.BUY),
                'SELL': signal_types.count(SignalType.SELL),
                'HOLD': signal_types.count(SignalType.HOLD),
                'ALERT': signal_types.count(SignalType.ALERT)
            },
            'high_confidence_signals': len([s for s in self.signals if s.confidence >= 0.8])
        }


class SignalGenerator:
    """Generates trading signals from rule execution results."""

    def __init__(self):
        self.signal_history: List[TradingSignal] = []
        self.max_history_size = 10000

    def generate_signal(
        self,
        rule_id: str,
        symbol: str,
        signal_type: SignalType,
        confidence: float,
        market_data: Dict[str, Any],
        risk_management: Optional[Dict[str, Any]] = None
    ) -> TradingSignal:
        """
        Generate a trading signal from rule execution results.

        Args:
            rule_id: ID of the rule that generated the signal
            symbol: Trading symbol
            signal_type: Type of signal (BUY/SELL/HOLD/ALERT)
            confidence: Confidence score (0-1)
            market_data: Current market data for the symbol
            risk_management: Risk management parameters

        Returns:
            TradingSignal object
        """
        # Extract price and volume from market data
        price = market_data.get('close', market_data.get('price'))
        volume = market_data.get('volume')
        entry_price = price

        # Apply risk management if provided
        stop_loss = None
        take_profit = None
        position_size_pct = None

        if risk_management:
            stop_loss_pct = risk_management.get('stop_loss_pct')
            take_profit_pct = risk_management.get('take_profit_pct')
            position_size_pct = risk_management.get('max_position_size_pct')

            if price and stop_loss_pct:
                if signal_type == SignalType.BUY:
                    stop_loss = price * (1 - stop_loss_pct)
                elif signal_type == SignalType.SELL:
                    stop_loss = price * (1 + stop_loss_pct)

            if price and take_profit_pct:
                if signal_type == SignalType.BUY:
                    take_profit = price * (1 + take_profit_pct)
                elif signal_type == SignalType.SELL:
                    take_profit = price * (1 - take_profit_pct)

        # Create signal
        signal = TradingSignal(
            symbol=symbol,
            rule_id=rule_id,
            signal_type=signal_type,
            confidence=confidence,
            price=price,
            volume=volume,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            position_size_pct=position_size_pct,
            metadata={
                'rule_execution_time': datetime.now().isoformat(),
                'market_data_snapshot': market_data
            }
        )

        # Calculate risk metrics
        signal.risk_metrics = self._calculate_risk_metrics(signal)

        # Add to history
        self._add_to_history(signal)

        logger.info(f"Generated signal: {signal.symbol} {signal.signal_type.value} "
                   f"(confidence: {signal.confidence:.2f})")

        return signal

    def generate_signals_batch(
        self,
        rule_results: List[Dict[str, Any]],
        risk_management: Optional[Dict[str, Any]] = None
    ) -> SignalBatch:
        """
        Generate multiple signals from rule execution results.

        Args:
            rule_results: List of rule execution results
            risk_management: Default risk management parameters

        Returns:
            SignalBatch containing all generated signals
        """
        batch = SignalBatch()

        for result in rule_results:
            try:
                signal = self.generate_signal(
                    rule_id=result['rule_id'],
                    symbol=result['symbol'],
                    signal_type=SignalType(result['signal_type']),
                    confidence=result['confidence'],
                    market_data=result.get('market_data', {}),
                    risk_management=result.get('risk_management', risk_management)
                )
                batch.add_signal(signal)
            except Exception as e:
                logger.error(f"Failed to generate signal for rule {result.get('rule_id')}: {e}")
                continue

        logger.info(f"Generated signal batch with {len(batch.signals)} signals")
        return batch

    def filter_signals(
        self,
        signals: List[TradingSignal],
        min_confidence: float = 0.0,
        signal_types: Optional[List[SignalType]] = None,
        symbols: Optional[List[str]] = None,
        max_signals: Optional[int] = None
    ) -> List[TradingSignal]:
        """
        Filter signals based on criteria.

        Args:
            signals: List of signals to filter
            min_confidence: Minimum confidence threshold
            signal_types: Allowed signal types
            symbols: Allowed symbols
            max_signals: Maximum number of signals to return

        Returns:
            Filtered list of signals
        """
        filtered = signals

        # Filter by confidence
        if min_confidence > 0:
            filtered = [s for s in filtered if s.confidence >= min_confidence]

        # Filter by signal type
        if signal_types:
            filtered = [s for s in filtered if s.signal_type in signal_types]

        # Filter by symbol
        if symbols:
            filtered = [s for s in filtered if s.symbol in symbols]

        # Limit number of signals
        if max_signals:
            # Sort by confidence descending and take top N
            filtered = sorted(filtered, key=lambda s: s.confidence, reverse=True)
            filtered = filtered[:max_signals]

        return filtered

    def validate_signals(self, signals: List[TradingSignal]) -> Dict[str, List[str]]:
        """
        Validate a list of signals.

        Returns:
            Dictionary mapping signal index to list of validation errors
        """
        validation_results = {}

        for i, signal in enumerate(signals):
            errors = signal.validate_signal()
            if errors:
                validation_results[i] = errors

        return validation_results

    def _calculate_risk_metrics(self, signal: TradingSignal) -> Dict[str, Any]:
        """Calculate risk metrics for a signal."""
        metrics = {}

        if signal.stop_loss and signal.entry_price:
            if signal.signal_type == SignalType.BUY:
                risk_amount = signal.entry_price - signal.stop_loss
            elif signal.signal_type == SignalType.SELL:
                risk_amount = signal.stop_loss - signal.entry_price
            else:
                risk_amount = 0

            metrics['risk_amount'] = risk_amount
            metrics['risk_pct'] = (risk_amount / signal.entry_price) * 100 if signal.entry_price > 0 else 0

        # Calculate risk-reward ratio
        rr_ratio = signal.calculate_risk_reward_ratio()
        if rr_ratio:
            metrics['risk_reward_ratio'] = rr_ratio

        # Position sizing
        if signal.position_size_pct:
            metrics['position_size_pct'] = signal.position_size_pct
            if signal.price:
                metrics['position_value'] = (signal.position_size_pct / 100) * signal.price

        return metrics

    def _add_to_history(self, signal: TradingSignal):
        """Add signal to history with size limit."""
        self.signal_history.append(signal)
        if len(self.signal_history) > self.max_history_size:
            self.signal_history.pop(0)

    def get_signal_history(
        self,
        limit: int = 100,
        symbol: Optional[str] = None,
        signal_type: Optional[SignalType] = None
    ) -> List[TradingSignal]:
        """Get signal history with optional filtering."""
        history = self.signal_history[-limit:]

        if symbol:
            history = [s for s in history if s.symbol == symbol]

        if signal_type:
            history = [s for s in history if s.signal_type == signal_type]

        return history

    def get_signal_statistics(self) -> Dict[str, Any]:
        """Get statistics about generated signals."""
        if not self.signal_history:
            return {}

        signals = self.signal_history
        confidences = [s.confidence for s in signals]
        signal_types = [s.signal_type for s in signals]

        return {
            'total_signals': len(signals),
            'avg_confidence': sum(confidences) / len(confidences),
            'max_confidence': max(confidences),
            'min_confidence': min(confidences),
            'signal_type_distribution': {
                'BUY': signal_types.count(SignalType.BUY),
                'SELL': signal_types.count(SignalType.SELL),
                'HOLD': signal_types.count(SignalType.HOLD),
                'ALERT': signal_types.count(SignalType.ALERT)
            },
            'unique_symbols': len(set(s.symbol for s in signals))
        }
